# Idea: 基于本地无头浏览器的高级反爬抓取方案

## 1. 背景与痛点
在抓取微信公众号、知乎、极客时间等平台时，传统的 HTTP 爬虫（Firecrawl, Jina Reader）受限于公有云 IP 质量和固定指纹，极易遭遇"环境异常"、"验证码"或"Forbidden"拦截。为了实现 100% 的抓取成功率，引入本地 Headless 浏览器驱动是目前公认的终极方案。

## 2. 核心推荐 Go 爬虫库对比

| 库名称 | 特点 | 适用场景 |
| :--- | :--- | :--- |
| **[go-rod](https://github.com/go-rod/rod)** | **首选推荐**。API 人性化，社区活跃。其 `stealth` 插件极其强大。 | 对抗微信、Cloudflare 等具有深度 JS 指纹检测的平台。 |
| **[chromedp](https://github.com/chromedp/chromedp)** | 原生 Go 实现，轻量级。直接操作 CDP 协议。 | 高并发、需要精细化控制浏览器行为的底层开发。 |
| **[playwright-go](https://github.com/playwright-community/playwright-go)** | Microsoft 官方协议的 Go 社区分支，稳定性极高。 | 需要跨浏览器（Firefox/WebKit）兼容性的复杂自动化。 |

## 3. 为什么本地实现能绕过高级反爬？

- **真实环境模拟**: 运行完整的 Chromium 引擎，执行所有 JavaScript 脚本，避开"仅检测 HTTP Header"的初级拦截。
- **隐藏自动化特征 (Stealth)**: 通过插件抹除 `navigator.webdriver` 等标识，使浏览器在特征检测中表现得像真实用户。
- **IP 信誉度**: 本地开发或家庭宽带 IP 的信誉权重远高于 AWS/阿里云等数据中心 IP。
- **Cookie 与场景持久化**: 能够持久化存储访问历史，模拟自然人的连续访问行为。

## 4. 架构建议 (Smart Fallback Strategy)

建议在 `DigEino` 调研工具集中采用"阶梯式切换"逻辑：

1. **L1 (Lightweight)**: 使用 `firecrawl` 或 `jina` (HTTP 模式)。
   - *优点*: 极快，资源占用极低。
2. **L2 (Local Browser)**: 当 L1 触发拦截关键字（如"环境异常"）时，自动激活。
   - *优点*: 渲染真实页面，绕过验证。
3. **L3 (Search Mirror)**: 若抓取均宣告失败，自动通过 `web_search` (Bocha/Google) 获取目标 URL 的搜索快照摘要。

## 5. 实现代码示例 (基于 go-rod)

以下是一个初步的 `LocalScraper` 实现原型，展示了如何通过 `stealth` 插件抓取微信页面内容：

```go
package research

import (
    "context"
    "time"
    "github.com/go-rod/rod"
    "github.com/go-rod/rod/lib/launcher"
    "github.com/go-rod/stealth"
)

func LocalScrape(url string) (string, error) {
    // 1. 启动并配置浏览器 (自动下载 Chromium)
    l := launcher.New().
        Headless(true). // 生产环境设为 true
        NoSandbox(true)

    browser := rod.New().ControlURL(l.MustLaunch()).MustConnect()
    defer browser.MustClose()

    // 2. 使用 Stealth 插件模拟真实用户
    page := stealth.MustPage(browser)
    
    // 3. 访问页面并等待加载
    err := page.Timeout(30 * time.Second).Navigate(url)
    if err != nil {
        return "", err
    }

    // 微信文章通常需要等待特定内容渲染
    page.MustWaitLoad()
    
    // 4. 获取 Markdown 或 HTML (此处示例获取文本)
    content := page.MustElement("#js_content").MustText()
    
    return content, nil
}
```

## 6. 部署与环境说明

### 开发环境 (macOS)
- **零配置体验**: 在 Mac 上测试时，`go-rod` 会自动拉起一个独立的 Chromium 实例。
- **可视化调试**: 可将 `Headless(false)` 设为可见模式，实时看机器人如何滚动页面。

### 生产环境 (CentOS)
- **依赖安装**: 需要安装基础图形库：`yum install libX11 libXcomposite atk gtk3` 等。
- **中文字体**: 必装 `google-noto-cjk-fonts`。
- **推荐方案**: **Docker 部署**。使用官方提供的内置 Chromium 镜像（如 `browserless/chrome`）可以避开宿主机的复杂库依赖。

## 7. 结论
引入本地 `rod` 驱动将作为 DigEino 的"终极盾牌"，能够有效穿透目前市面上绝大多数基于指纹和环境的反爬拦截。

---

## 8. 附录：可行性评估与补充说明

### 8.1 方案可行性评估（2026-02-22）

#### 一、方案概述

文档提出的核心思路是：当 Firecrawl 和 Jina Reader（均为云端 HTTP 代理）在抓取微信公众号等平台时遭遇反爬拦截，引入**本地 go-rod + stealth** 作为 L2 兜底方案，形成「L1 HTTP → L2 本地浏览器 → L3 搜索摘要」的阶梯式切换策略。

#### 二、可行性结论：整体可行，但需注意若干技术细节与约束

**技术选型评估**

| 评估项 | 结论 |
|--------|------|
| go-rod + stealth | 选型合理。go-rod 社区活跃，stealth 基于 puppeteer-extra 的 evasions，可隐藏 `navigator.webdriver` 等自动化特征，对 Cloudflare、微信等 JS 指纹检测有一定效果。 |
| 库成熟度 | go-rod 持续维护；stealth 最新 v0.4.9（2023 年），依赖 go-rod v0.113.0，API 稳定。 |
| 与现有架构兼容 | DigEino 已有 `FirecrawlScrape`、`JinaReader` 等工具，均采用 `utils.InferTool` 注册，新增 `LocalScraper` 可无缝接入，接口形态一致（URL → Markdown）。 |

**文档代码示例需修正的点**

1. **stealth.MustPage 与 launcher 的配合**：stealth 创建的是新空白页，`Navigate` 应在该页上调用，示例逻辑是对的。
2. **微信文章选择器 `#js_content`**：建议增加 `page.MustWait("#js_content")` 等待正文出现，或使用 `page.Timeout(...).Element("#js_content")` 并处理元素不存在的情况。
3. **HTML → Markdown 转换**：若需与 Firecrawl/Jina 一致的 Markdown 输出，需要额外引入 `github.com/JohannesKaufmann/html-to-markdown`。
4. **浏览器生命周期**：每次请求都启动新 Chromium 实例延迟较高（约 2–5 秒）。生产环境建议使用浏览器池或连接远程 `browserless/chrome`。

**微信公众号反爬的特殊性**

- Session/Cookie 校验、Token 校验、流量限制、JS 指纹
- 本地浏览器 + stealth 主要解决自动化特征检测，对「环境异常」类拦截有帮助
- 若拦截来自 IP 信誉或登录态，本地方案不一定能完全解决

**实施建议**：先做 POC 验证，再补 Markdown，最后接入 fallback 策略。

---

### 8.2 云端 CentOS 部署：内存与并发建议

**经验公式（Browserless 官方）**：约 10 个并发会话 / GB 内存，即每个并发 Chromium 会话约 100MB。

**单实例内存范围**

| 状态 | 单实例内存 |
|------|------------|
| 空闲 | 50–150 MB |
| 正常浏览（如微信文章） | 200–500 MB |
| 复杂 SPA | 500–2000 MB |

**推荐配置**

| 并发数 | 浏览器预估内存 | 系统总内存建议 |
|--------|----------------|----------------|
| 1–2 | 0.5–1 GB | 4 GB |
| 3–5 | 1–2 GB | 4–6 GB |
| 5–10 | 2–4 GB | 6–8 GB |
| 10+ | 4 GB+ | 8 GB+ |

**最低要求**：Browserless 官方建议至少 2 CPU 核 + 4 GB RAM。若同一台机器跑 DigFlow/DigEino，需额外预留 0.5–1 GB。

**结论**：最低 4 GB（并发 1–2），生产推荐 6–8 GB（并发 3–5），并配合 `CONCURRENT` 和队列控制。

---

### 8.3 Cursor 的 Web Search 和 Fetch Page 实现

**内置能力（@Web）**：Cursor 自带 @Web，根据问题构造搜索查询并注入上下文。具体实现未开源。

**MCP 工具**：在 Composer/Agent 模式下，Cursor 通过 MCP 调用工具。常见来源包括：
- `user-firecrawl-mcp`：`firecrawl_search`（搜索）、`firecrawl_scrape`（抓取）
- 内置 `mcp_web_fetch`：从 URL 拉取页面并转为 Markdown

**与 DigFlow/DigEino 的对比**：Cursor 和你项目一样，主要依赖云端 HTTP 抓取（Firecrawl 等），遇到微信等强反爬时同样会被拦截。本地 go-rod 方案是 Cursor 目前没有提供的差异化能力。

---

### 8.4 Firecrawl Search 接入 DigEino web_search 的可行性

**结论：可以添加。**

DigEino 的 `web_search` 已支持多引擎切换（Bocha、SerpAPI、Google、Bing、DuckDuckGo），新增 Firecrawl 只需实现一个 Provider 并注册即可。

**Firecrawl Search API 概况**

| 项目 | 说明 |
|------|------|
| 端点 | `POST https://api.firecrawl.dev/v2/search` |
| 认证 | Bearer Token（与 firecrawl_scrape 共用 ApiKey） |
| 参数 | `query`, `limit`（默认 5，最大 100） |
| 响应 | `data.web[]`，含 `url`, `title`, `description` |

**实现要点**

1. 新建 `tools/research/websearch/firecrawl.go`，实现 `SearchProvider` 接口
2. 复用 `config.Tools.Firecrawl.ApiKey`，无需新增配置
3. 在 `web_search.go` 的 switch 中增加 `case "firecrawl"`

**配置示例（eino.yml）**

```yaml
Tools:
  WebSearch:
    Engine: "firecrawl"
  Firecrawl:
    ApiKey: "fc-xxx"   # 与 firecrawl_scrape 共用
```
